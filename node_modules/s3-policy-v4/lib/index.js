'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * S3Policy
 */

var CryptoJS = require('crypto-js');
var Buffer = global.Buffer || require('buffer').Buffer;

var assert = function assert(object, message) {
  if (object == null) throw new Error(message);
};

var FIVE_MINUTES = 5 * 60 * 1000;

var AWS_ACL = 'public-read';
var AWS_SERVICE_NAME = 's3';
var AWS_REQUEST_POLICY_VERSION = 'aws4_request';
var AWS_ALGORITHM = 'AWS4-HMAC-SHA256';

var DEFAULT_SUCCESS_ACTION_STATUS = '201';

var getDate = function getDate() {
  var date = new Date();
  var yymmdd = date.toISOString().slice(0, 10).replace(/-/g, '');
  var amzDate = yymmdd + 'T000000Z';
  return { yymmdd: yymmdd, amzDate: amzDate };
};

/*
 * Expires in 5 minutes. Amazon will reject request
 * if it arrives after the expiration date.
 *
 * returns string in ISO8601 GMT format, i.e.
 *
 *     2016-03-24T20:43:47.314Z
 */
var getExpirationDate = function getExpirationDate() {
  return new Date(Date.now() + FIVE_MINUTES).toISOString();
};

var getPolicyParams = function getPolicyParams(options) {
  var date = getDate();
  var expiration = getExpirationDate();

  return {
    acl: AWS_ACL,
    algorithm: AWS_ALGORITHM,
    bucket: options.bucket,
    contentType: options.contentType,
    credential: options.accessKey + '/' + date.yymmdd + '/' + options.region + '/' + AWS_SERVICE_NAME + '/' + AWS_REQUEST_POLICY_VERSION,
    date: date,
    expiration: expiration,
    key: options.key,
    region: options.region,
    secretKey: options.secretKey,
    successActionStatus: String(options.successActionStatus || DEFAULT_SUCCESS_ACTION_STATUS),
    metadata: options.metadata || {}
  };
};

var formatPolicyForEncoding = function formatPolicyForEncoding(policy) {
  return {
    expiration: policy.expiration,
    conditions: [{ bucket: policy.bucket }, { key: policy.key }, { acl: policy.acl }, { success_action_status: policy.successActionStatus }, { 'Content-Type': policy.contentType }, { 'x-amz-credential': policy.credential }, { 'x-amz-algorithm': policy.algorithm }, { 'x-amz-date': policy.date.amzDate }].concat(_toConsumableArray(Object.keys(policy.metadata).map(function (k) {
      return _defineProperty({}, k, String(policy.metadata[k]));
    })))
  };
};

var getEncodedPolicy = function getEncodedPolicy(policy) {
  return new Buffer(JSON.stringify(policy), 'utf-8').toString('base64');
};

var getSignatureKey = function getSignatureKey(options) {
  var kDate = CryptoJS.HmacSHA256(options.date.yymmdd, 'AWS4' + options.secretKey);
  var kRegion = CryptoJS.HmacSHA256(options.region, kDate);
  var kService = CryptoJS.HmacSHA256(AWS_SERVICE_NAME, kRegion);
  var kSigning = CryptoJS.HmacSHA256(AWS_REQUEST_POLICY_VERSION, kService);

  return kSigning;
};

var getSignature = function getSignature(base64EncodedPolicy, options) {
  return CryptoJS.HmacSHA256(base64EncodedPolicy, getSignatureKey(options)).toString(CryptoJS.enc.Hex);
};

var formatPolicyForRequestBody = function formatPolicyForRequestBody(base64EncodedPolicy, signature, options) {
  return {
    key: options.key,
    acl: options.acl,
    success_action_status: options.successActionStatus,
    'Content-Type': options.contentType,
    'X-Amz-Credential': options.credential,
    'X-Amz-Algorithm': options.algorithm,
    'X-Amz-Date': options.date.amzDate,
    Policy: base64EncodedPolicy,
    'X-Amz-Signature': signature
  };
};

var S3Policy = exports.S3Policy = function () {
  function S3Policy() {
    _classCallCheck(this, S3Policy);
  }

  _createClass(S3Policy, null, [{
    key: 'generate',
    value: function generate(options) {
      assert(options, 'Must provide options');
      assert(options.key, 'Must provide `key` option with the object key');
      assert(options.bucket, 'Must provide `bucket` option with your AWS bucket name');
      assert(options.contentType, 'Must provide `contentType` option with the object content type');
      assert(options.region, 'Must provide `region` option with your AWS region');
      assert(options.accessKey, 'Must provide `accessKey` option with your AWSAccessKeyId');
      assert(options.secretKey, 'Must provide `secretKey` option with your AWSSecretKey');

      var policyParams = getPolicyParams(options);
      var policy = formatPolicyForEncoding(policyParams);
      var base64EncodedPolicy = getEncodedPolicy(policy);
      var signature = getSignature(base64EncodedPolicy, policyParams);

      return formatPolicyForRequestBody(base64EncodedPolicy, signature, policyParams);
    }
  }]);

  return S3Policy;
}();

exports.default = S3Policy;